/**
 * Report Generator Utility
 * Generates PDF reports from visualizations and chat data
 */

import html2canvas from "html2canvas"

export interface ReportConfig {
  title: string
  description?: string
  includeTimestamp?: boolean
  includeMetadata?: boolean
}

export interface ReportSection {
  title: string
  content: string
  visualizationElement?: HTMLElement
}

/**
 * Generate a PDF report from HTML elements
 */
export async function generatePDFReport(
  sections: ReportSection[],
  config: ReportConfig
): Promise<Blob> {
  // We'll use a simple approach: convert HTML to canvas, then to PDF-like document
  // For a production app, you might want to use jsPDF library

  const { title, description, includeTimestamp = true } = config

  // Create a container for the report
  const reportContainer = document.createElement("div")
  reportContainer.style.cssText = `
    width: 800px;
    padding: 40px;
    background: white;
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
  `

  // Add header
  const header = document.createElement("div")
  header.innerHTML = `
    <div style="border-bottom: 3px solid #3b82f6; padding-bottom: 20px; margin-bottom: 30px;">
      <h1 style="font-size: 32px; font-weight: bold; color: #1e293b; margin: 0 0 10px 0;">
        ${title}
      </h1>
      ${description ? `<p style="color: #64748b; font-size: 16px; margin: 0;">${description}</p>` : ""}
      ${includeTimestamp ? `<p style="color: #94a3b8; font-size: 14px; margin: 10px 0 0 0;">
        Generated on ${new Date().toLocaleString()}
      </p>` : ""}
    </div>
  `
  reportContainer.appendChild(header)

  // Add sections
  for (const section of sections) {
    const sectionDiv = document.createElement("div")
    sectionDiv.style.cssText = "margin-bottom: 40px; page-break-inside: avoid;"

    const sectionTitle = document.createElement("h2")
    sectionTitle.textContent = section.title
    sectionTitle.style.cssText = `
      font-size: 24px;
      font-weight: 600;
      color: #334155;
      margin: 0 0 15px 0;
    `
    sectionDiv.appendChild(sectionTitle)

    const sectionContent = document.createElement("div")
    sectionContent.innerHTML = section.content
    sectionContent.style.cssText = `
      color: #475569;
      font-size: 14px;
      line-height: 1.6;
      margin-bottom: 20px;
    `
    sectionDiv.appendChild(sectionContent)

    // Add visualization if present
    if (section.visualizationElement) {
      const canvas = await html2canvas(section.visualizationElement, {
        backgroundColor: "#ffffff",
        scale: 2,
      })
      const img = document.createElement("img")
      img.src = canvas.toDataURL()
      img.style.cssText = "max-width: 100%; height: auto; border-radius: 8px; box-shadow: 0 1px 3px rgba(0,0,0,0.1);"
      sectionDiv.appendChild(img)
    }

    reportContainer.appendChild(sectionDiv)
  }

  // Add footer
  const footer = document.createElement("div")
  footer.innerHTML = `
    <div style="border-top: 2px solid #e2e8f0; padding-top: 20px; margin-top: 40px; text-align: center;">
      <p style="color: #94a3b8; font-size: 12px; margin: 0;">
        Generated by TouchBase IO AI Analytics
      </p>
    </div>
  `
  reportContainer.appendChild(footer)

  // Append to body temporarily
  reportContainer.style.position = "absolute"
  reportContainer.style.left = "-9999px"
  document.body.appendChild(reportContainer)

  // Convert to canvas
  const canvas = await html2canvas(reportContainer, {
    backgroundColor: "#ffffff",
    scale: 2,
    logging: false,
  })

  // Remove temporary element
  document.body.removeChild(reportContainer)

  // Convert canvas to blob
  return new Promise((resolve, reject) => {
    canvas.toBlob((blob) => {
      if (blob) {
        resolve(blob)
      } else {
        reject(new Error("Failed to generate report"))
      }
    }, "image/png")
  })
}

/**
 * Download a blob as a file
 */
export function downloadBlob(blob: Blob, filename: string) {
  const url = URL.createObjectURL(blob)
  const link = document.createElement("a")
  link.href = url
  link.download = filename
  document.body.appendChild(link)
  link.click()
  document.body.removeChild(link)
  URL.revokeObjectURL(url)
}

/**
 * Generate and download a report
 */
export async function generateAndDownloadReport(
  sections: ReportSection[],
  config: ReportConfig,
  filename?: string
) {
  const blob = await generatePDFReport(sections, config)
  const defaultFilename = `${config.title.toLowerCase().replace(/\s+/g, "-")}-${Date.now()}.png`
  downloadBlob(blob, filename || defaultFilename)
}

/**
 * Extract report sections from chat messages and visualizations
 */
export function extractReportSections(
  messages: any[],
  visualizations: any[]
): ReportSection[] {
  const sections: ReportSection[] = []

  // Add conversation summary
  const userMessages = messages.filter((m) => m.role === "user")
  const aiMessages = messages.filter((m) => m.role === "assistant")

  if (userMessages.length > 0) {
    sections.push({
      title: "Conversation Summary",
      content: `
        <p><strong>Total Messages:</strong> ${messages.length}</p>
        <p><strong>User Queries:</strong> ${userMessages.length}</p>
        <p><strong>AI Responses:</strong> ${aiMessages.length}</p>
      `,
    })
  }

  // Add key insights from AI responses
  if (aiMessages.length > 0) {
    const insights = aiMessages
      .slice(-3) // Last 3 messages
      .map((msg, idx) => `<p><strong>Insight ${idx + 1}:</strong> ${msg.content.substring(0, 200)}...</p>`)
      .join("")

    sections.push({
      title: "Key Insights",
      content: insights,
    })
  }

  return sections
}
